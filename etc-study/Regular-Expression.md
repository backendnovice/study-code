# 정규 표현식

정규표현식(Regular Expression)은 특정 규칙을 갖는 문자열의 집합을 표현할 때 사용하는 형식 언어이다. 대부분의 프로그래밍 언어들은 문자열 검색 및 변환에 정규표현식을 사용한다.

정규표현식은 다양한 문자열들을 다음과 같은 Meta 문자들을 사용하여 처리한다.

| 표현식 | 설명                                          | 비고            |
| ------ | --------------------------------------------- | --------------- |
| .      | 문자 하나를 의미한다.                         |                 |
| \*     | 와일드 카드, 여러 문자를 의미한다.            |                 |
| ?      | 0 또는 1개의 문자를 의미한다.                 |                 |
| ^      | 표현식의 시작을 결정한다.                     |                 |
| $      | 표현식의 종료를 결정한다.                     |                 |
| +      | 해당하는 여러 문자를 검색한다.                |                 |
| []     | 문자 집합 또는 범위를 나타낸다.               |                 |
| {}     | 횟수나 범위를 의미한다.                       | {m, n}          |
| ()     | 괄호 안의 문자들을 하나의 문자로 인식한다.    |                 |
| \|     | 패턴의 OR 연산을 수행한다.                    |                 |
| [xy]   | x,y 중 하나의 문자를 검색한다.                |                 |
| [^xy]  | x,y 를 제외한 하나의 문자를 검색한다.         |                 |
| [a-z]  | a~z 사이의 하나의 문자를 검색한다.            |                 |
| \^     | "^(특수문자)"를 식에서 사용한다.              |                 |
| \b     | 문자와 공백 사이의 문자를 검색한다.           |                 |
| \B     | 문자와 공백 사이가 아닌 값을 검색한다.        |                 |
| \d     | 숫자를 검색한다.                              | [0-9]           |
| \D     | 숫자가 아닌 문자를 검색한다.                  | [^0-9]          |
| \s     | 공백 문자를 검색한다.                         | [\t\n\x0b\r\f]  |
| \S     | 공백이 아닌 문자를 검색한다.                  | [^\t\n\x0b\r\f] |
| \t     | Tab 문자를 검색한다.                          |                 |
| \v     | Vertical Tab 문자를 검색한다.                 |                 |
| \w     | "알파벳 + 숫자 + \_" 을 포함한 값을 검색한다. | [a-zA-Z_0-9]    |
| \W     | "알파벳 + 숫자 + \_" 을 제외한 값을 검색한다. | [^a-zA-Z_0-9]   |
| g      | 전체에 매칭하는 옵션 플래그.                  | Global          |
| i      | 대소문자를 무시하는 옵션 플래그.              | IgnoreCase      |
| m      | 여러 줄을 매칭한다 옵션 플래그.               | MultiLine       |

정규표현식은 프로그래밍 언어와 프레임워크에 따라서 차이를 보인다. 예를들어 Java와 Javascript를 비교하면 다음과 같다.

| 차이점        | Java                             | Javascript               |
| ------------- | -------------------------------- | ------------------------ |
| 리터럴 여부   | 문자열 형태로 작성. ("\\\\s")    | 리터럴 형태로 생성. (\s) |
| 패턴 매칭     | Matcher, Pattern 클래스 사용.    | match() 메서드 사용.     |
| 옵션 플래그   | Pattern 클래스의 compile() 사용. | 리터럴 뒤에 붙여서 사용. |
| 예외 처리     | 예외 처리 반드시 필요.           | 예외 처리 필요 없음.     |
| 유니코드 지원 | 유니코드 정상 지원.              | \u를 통해서 표현.        |

웹 개발 환경에서 비즈니스 로직에 필요한 데이터의 필터 역할을 수행하는데 유용하게 사용할 수 있다. 다음은 대표적인 예제들이다.

- 특정 단어로 끝나는지 검사.

```js
// html로 끝나는지 검사하는 표현식.
const regexp = /html$/;
```

- 숫자로 이루어져 있는지 검사.

```js
// 하나 이상의 숫자로 이루어져 있는지 검사하는 표현식.
const regexp = /^\d+$/;
```

- 올바른 아이디 형식 검사.

```js
// 알파벳 대소문자 또는 숫자로 시작. 범위는 4 ~ 10 자리.
const regexp = /^[A-Za-z0-9]{4, 10}$/;
```

- 휴대 전화 번호 형식 검사.

```js
// 010-0000-0000의 형식.
const regexp = /^\d{3}-\d{4}-\d{4}$/;
```

- 웹 사이트 주소 형식 검사.

```js
// http(s):// 로 시작하여 알파벳, 숫자, '_', '-', '.'으로 이루어짐.
// TLD의 규칙에 따라서 최소 두 글자 이상으로 구성할 것.
const regexp = /^https?:\/\/[\w\-\.]+\.[a-z]{2,}$/g;
```

- 이메일 주소 형식 검사.

```js
// xx.xxx@xxxx.com의 형식.
const regexp =
  /^[0-9a-zA-Z]([-_\.]?[0-9a-zA-Z])*@[0-9a-zA-Z]([-_\.]?[0-9a-zA-Z])*\.[a-zA-Z]{2,3}$/;
```

- 비밀번호 형식 검사.

```js
// 숫자, 대소문자를 하나 이상 포함하는 문자열. 범위는 6 ~ 20 자리.
// 전방 탐색(Lookahead Assertion)을 사용.
const regexp = /^.*(?=.{6, 20})(?=.*[0-9])(?=.*[a-zA-Z]).*$/;
```

원하는 문자열을 검색하기 위해서 찾을 순서를 정해야 할 때, 전후방탐색(Lookaround Assertion)을 사용할 수 있다.

전방 탐색(Lookahead Assertion)은 일치 영역을 탐색하나, 반환하지 않는 패턴이다.

- URL 프로토콜 검사.

```js
// http: | https: | ftp: |
const regexp = /^.*(?=:)$/;
```

후방 탐색(Lookbehind Assertion)은 문자열을 반환하기 전에 뒤쪽을 탐색하는 패턴이다.

- 일련번호의 금액을 출력.

```js
// ABC01: $23.45 -> 23.45
const regexp = /^(?<=\$)[0-9.]+$/;
```
